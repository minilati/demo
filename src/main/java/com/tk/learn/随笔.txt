设计模式的目的
1)代码重用性(相同功能的代码，不用多次编写)
2)可读性(编程规范性,便于阅读和理解)
3)可扩展性(增加新功能时非常方便，称为可维护)
4)可靠性(增加新功能后，对原功能没有影响)
5)使程序呈现高内聚，低耦合的特性

设计模式七大原则
1)单一职责原则
一个类只负责一项职责。

2)接口隔离原则
一个类对另一个类的依赖应该建立在最小的接口上，细化接口，接口中的方法尽量少。

3)依赖倒转原则
中心思想是面向接口编程。
高层模块不应该依赖低层模块，二者都应该依赖其抽象。
抽象不应该依赖细节，细节应该依赖抽象。
传递依赖关系有三种方式：接口传递，构造方法传递，setter方法传递。
抽象的接口或抽象类比具体的实现类更稳定。


4)里氏替换原则
子类可以实现父类的抽象方法，但不能重写父类的非抽象方法。
子类中可以增加自己特有的方法。
继承让两个类的耦合度增强，可以通过聚合、组合、依赖来解决问题。

5)开闭原则
对扩展开放，对修改关闭。
用抽象构建框架，用实现扩展细节。
遵循其它原则，使用设计模式的目的就是遵循开闭原则。

6)迪米特法则
一个类对依赖的类知道的越少越好，被依赖的类应该将逻辑封装在内部，对外只提供public方法。
出现成员变量、方法参数、方法返回值中的类为直接朋友。类只与直接朋友通信。
出现在局部变量中的不是直接朋友，陌生类尽量不要以局部变量形式出现在类中。

7)合成复用原则
尽量使用合成/聚合的方式，而不是使用继承。

UML类图用于描述类的组成和类之间的各种静态关系。
1)依赖
①类中用到了对方
②是类的成员属性
③是方法的返回类型
④是方法接收的参数类型
⑤方法中使用到（虽然违反迪米特法则）

2)泛化
泛化就是继承关系，是依赖关系的特例。

3)实现
实现就是A类实现B接口，是依赖关系的特例

4)关联
关联就是类与类之间的联系，是依赖关系的特例。
具有导航性，即双向关系或单向关系。
单向：A类中有B类成员属性。
双向：A类中有B类成员属性，B类中有A类成员属性。

5)聚合
是整体和部分的关系，整体和部分可以分开，是关联关系的特例。
具有关联的导航性与多重性。
A类对象创建后，B类对象可以随时创建与销毁。

6)组合
是整体与部分的关系，整体与部分不可以分开。
A类对象一旦创建，B类对象也会被创建。A类对象一旦销毁，B类对象也会被销毁。


设计模式分为三种类型（共23种）
1)创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。
2)结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
3)行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)。


单例设计模式八种方式
1)饿汉式(静态常量)
构造器私有化(防止new)
类的内部创建对象（private final static A a = new A()）
向外暴露一个静态公共方法来获取对象。
优点：类装载时完成实例化，避免了线程同步问题。
缺点：可能提前导致类装载从而创建对象，没有达到懒加载的效果。如果一直不用这个对象，则会造成内存浪费。

2)饿汉式（静态代码块）
将类实例化的过程放在了静态代码块中（private final static A a; static{a = new A();}）
也是在类加载时完成实例化，同上。

3)懒汉式(线程不安全)
向外暴露一个静态公共方法来获取对象。
在获取对象时，判断对象是否被创建，若对象为空则创建。
起到了懒加载的效果，但是只能在单线程下使用。
如果在多线程下，多个线程同时判断对象为空，则会创建多个对象，因此不是单例模式。

4)懒汉式(线程安全，同步方法)
在获取对象的方法上加上synchronized锁。
虽然解决线程安全问题，但是效率低下，实际只需进行一次实例化，后续请求可直接返回对象没必要同步。

6)双重检查
volatile修饰对象，在获取对象方法内部两个if判断间加synchronized锁。
private static volatile A a;
if(a==null){   synchronized(A.class){   if(a==null) {   a=new A()...
用volatile修饰对象防止指令重排序。new一个对象并不是原子指令，分为3步：
1.分配对象内存
2.调用构造器执行初始化
3.将对象引用赋值给变量
第1步先执行，第2、3步可能发生重排序。
当线程A执行完1,3步却还未初始化对象时，线程B会因为判断该对象非空而去访问对象造成异常。
延迟加载，效率较高，推荐使用！

7)静态内部类
在类中写一个静态内部类，其中有一个主类对象的静态属性。
获取对象时直接返回内部类的静态属性。
class A{
private static A a;
private static class AIns{ private static final A a=new A();}
private static A getA(){return AIns.a;}
}
静态内部类只有在第一次被调用时才会加载，并且类的静态属性只会在第一次加载类时初始化。
线程安全，延迟加载，效率高，推荐使用。

8)枚举
在类中定义一个枚举类，枚举类中有一个枚举对象和主类对象，并在构造器中初始化主类，对外暴露公共方法返回主类对象。
class A{
enum AIns{		//枚举类只能自己实例化
INSTANCE;		//枚举类对象
private final A a;		//主类对象
AIns(){a=new A();}		//构造器中初始化主类
public A getA(){return a;}	//对外暴露获取对象方法
线程安全，延迟加载，防止反序列化，推荐使用！

工厂模式
1)简单工厂模式
定义一个产品接口，多个产品实现类，一个工厂类。
在工厂类中定义一个公共静态方法，根据传入的参数创建对应产品对象并返回。
（工厂类中用静态方法可以直接用工厂类生产对象而不用创建工厂对象，不过子工厂类继承工厂类后无法重写静态的生产方法）

2)工厂方法模式
定义一个产品接口，多个产品实现类，一个工厂抽象类，多个工厂实现类。
将原本工厂创建产品对象的任务分发给多个具体工厂实现类。
在工厂实现类中重写生产方法，创建对应产品对象并返回。
（这里因为要重写生产方法，所以工厂类的生产方法是非静态的，也就需要创建工厂对象调用方法来生产对象）

3)抽象工厂模式
定义多个产品接口，多个产品实现类，一个工厂抽象类，多个工厂实现类。
与工厂方法模式不同的是，不需要每多一种产品就创建一个工厂实现类。
而是在工厂抽象类中增加创建产品对象的接口，再由工厂实现类重写生产方法，创建对应产品对象并返回。
（如果某些产品只有部分工厂实现类能生产，那么该产品生产方法不应写进接口，而是直接写进实现类？）

原型模式
1)浅拷贝
拷贝的类实现Cloneable接口，重写clone方法。
对于基本数据类型的成员变量，浅拷贝进行值传递。（String也是值传递）
对于引用数据类型的成员变量，浅拷贝进行引用（内存地址）传递，导致多个拷贝对象共用一个成员变量。

2)深拷贝
拷贝的类及成员对象的类实现Serializable接口。
在克隆方法内通过字节数组流和对象流将其序列化，再反序列化。
（也可以用JSON工具类将其序列化成JSON）

建造者模式



















JDK中RunTime类的单例模式就是饿汉式(静态常量)。
JDK中Calendar，Logger类的对象创建就是简单工厂模式。
Spring中getBean用到了原型模式。










synchronized 禁止重排序是通过内存屏障实现的, 简单来说, 内存屏障只保证指令不会越过该屏障, 而synchronized块内部的指令仍然有可能发生重排序


静态方法属于类，在编译阶段类被加载时，类的静态方法或者属性就会被分配内存，存储到类所在的内存中（堆内存的方法区中）；而类的非静态方法却是属于对象的，每个对象都有一份非静态方法的引用，并且若方法被重写，引用的就是子类重写的方法，且这是在运行时创建；
正因如此，即使子类重写了父类的静态方法，但是本质上它们还是两个独立的类，在内存中分别占用不同的内存，它们的静态方法也是在编译时就被加载，独立的占用着不同的内存。上面的代码中，一个父类的变量，指向子类的对象，调用一个被子类重写的静态方法时，由于这是一个父类的变量，并且静态方法属于类，所以在调用时，JVM会去父类所在的内存中寻找这个方法，所以最终的结果就是调用父类的方法，而不是子类重写的方法。

 