设计模式的目的
1)代码重用性(相同功能的代码，不用多次编写)
2)可读性(编程规范性,便于阅读和理解)
3)可扩展性(增加新功能时非常方便，称为可维护)
4)可靠性(增加新功能后，对原功能没有影响)
5)使程序呈现高内聚，低耦合的特性

设计模式七大原则
1)单一职责原则
一个类只负责一项职责。

2)接口隔离原则
一个类对另一个类的依赖应该建立在最小的接口上，细化接口，接口中的方法尽量少。

3)依赖倒转原则
中心思想是面向接口编程。
高层模块不应该依赖低层模块，二者都应该依赖其抽象。
抽象不应该依赖细节，细节应该依赖抽象。
传递依赖关系有三种方式：接口传递，构造方法传递，setter方法传递。
抽象的接口或抽象类比具体的实现类更稳定。

4)里氏替换原则
子类可以实现父类的抽象方法，但不能重写父类的非抽象方法。
子类中可以增加自己特有的方法。
继承让两个类的耦合度增强，可以通过聚合、组合、依赖来解决问题。

5)开闭原则
对扩展开放，对修改关闭。
用抽象构建框架，用实现扩展细节。
遵循其它原则，使用设计模式的目的就是遵循开闭原则。

6)迪米特法则
一个类对依赖的类知道的越少越好，被依赖的类应该将逻辑封装在内部，对外只提供public方法。
出现成员变量、方法参数、方法返回值中的类为直接朋友。类只与直接朋友通信。
出现在局部变量中的不是直接朋友，陌生类尽量不要以局部变量形式出现在类中。

7)合成复用原则
尽量使用合成/聚合的方式，而不是使用继承。

UML类图用于描述类的组成和类之间的各种静态关系。
1)依赖
①类中用到了对方
②是类的成员属性
③是方法的返回类型
④是方法接收的参数类型
⑤方法中使用到（虽然违反迪米特法则）

2)泛化
泛化就是继承关系，是依赖关系的特例。

3)实现
实现就是A类实现B接口，是依赖关系的特例

4)关联
关联就是类与类之间的联系，是依赖关系的特例。
具有导航性，即双向关系或单向关系。
单向：A类中有B类成员属性。
双向：A类中有B类成员属性，B类中有A类成员属性。

5)聚合
是整体和部分的关系，整体和部分可以分开，是关联关系的特例。
具有关联的导航性与多重性。
A类对象创建后，B类对象可以随时创建与销毁。

6)组合
是整体与部分的关系，整体与部分不可以分开。
A类对象一旦创建，B类对象也会被创建。A类对象一旦销毁，B类对象也会被销毁。


设计模式分为三种类型（共23种）
1)创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。
2)结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
3)行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)。

单例设计模式八种方式
1)饿汉式(静态常量)
构造器私有化(防止new)
类的内部创建对象（private final static A a = new A()）
向外暴露一个静态公共方法来获取对象。
优点：类装载时完成实例化，避免了线程同步问题。
缺点：可能提前导致类装载从而创建对象，没有达到懒加载的效果。如果一直不用这个对象，则会造成内存浪费。

2)饿汉式（静态代码块）
将类实例化的过程放在了静态代码块中（private final static A a; static{a = new A();}）
也是在类加载时完成实例化，同上。

3)懒汉式(线程不安全)
向外暴露一个静态公共方法来获取对象。
在获取对象时，判断对象是否被创建，若对象为空则创建。
起到了懒加载的效果，但是只能在单线程下使用。
如果在多线程下，多个线程同时判断对象为空，则会创建多个对象，因此不是单例模式。

4)懒汉式(线程安全，同步方法)
在获取对象的方法上加上synchronized锁。
虽然解决线程安全问题，但是效率低下，实际只需进行一次实例化，后续请求可直接返回对象没必要同步。

6)双重检查
volatile修饰对象，在获取对象方法内部两个if判断间加synchronized锁。
private static volatile A a;
if(a==null){   synchronized(A.class){   if(a==null) {   a=new A()...
用volatile修饰对象防止指令重排序。new一个对象并不是原子指令，分为3步：
1.分配对象内存
2.调用构造器执行初始化
3.将对象引用赋值给变量
第1步先执行，第2、3步可能发生重排序。
当线程A执行完1,3步却还未初始化对象时，线程B会因为判断该对象非空而去访问对象造成异常。
延迟加载，效率较高，推荐使用！

7)静态内部类
在类中写一个静态内部类，其中有一个主类对象的静态属性。
获取对象时直接返回内部类的静态属性。
class A{
private static A a;
private static class AIns{ private static final A a=new A();}
private static A getA(){return AIns.a;}
}
静态内部类只有在第一次被调用时才会加载，并且类的静态属性只会在第一次加载类时初始化。
线程安全，延迟加载，效率高，推荐使用。

8)枚举
在类中定义一个枚举类，枚举类中有一个枚举对象和主类对象，并在构造器中初始化主类，对外暴露公共方法返回主类对象。
class A{
enum AIns{		//枚举类只能自己实例化
INSTANCE;		//枚举类对象
private final A a;		//主类对象
AIns(){a=new A();}		//构造器中初始化主类
public A getA(){return a;}	//对外暴露获取对象方法
线程安全，延迟加载，防止反序列化，推荐使用！

工厂模式
解耦，使对象的创建和使用分开，易于扩展，符合开闭原则，封装性，对外只暴露基类，不用自己准备参数new对象。
1)简单工厂模式
定义一个产品接口，多个产品实现类，一个工厂类。
在工厂类中定义一个公共静态方法，根据传入的参数创建对应产品对象并返回。
（工厂类中用静态方法可以直接用工厂类生产对象而不用创建工厂对象，不过子工厂类继承工厂类后无法重写静态的生产方法）

2)工厂方法模式
定义一个产品接口，多个产品实现类，一个工厂抽象类，多个工厂实现类。
将原本工厂创建产品对象的任务分发给多个具体工厂实现类。
在工厂实现类中重写生产方法，创建对应产品对象并返回。
（这里因为要重写生产方法，所以工厂类的生产方法是非静态的，也就需要创建工厂对象调用方法来生产对象）

3)抽象工厂模式
定义多个产品接口，多个产品实现类，一个工厂抽象类，多个工厂实现类。
与工厂方法模式不同的是，不需要每多一种产品就创建一个工厂实现类。
而是在工厂抽象类中增加创建产品对象的接口，再由工厂实现类重写生产方法，创建对应产品对象并返回。
（如果某些产品只有部分工厂实现类能生产，那么该产品生产方法不应写进接口，而是直接写进实现类？）

原型模式
1)浅拷贝
拷贝的类实现Cloneable接口，重写clone方法。
对于基本数据类型的成员变量，浅拷贝进行值传递。（String也是值传递）
对于引用数据类型的成员变量，浅拷贝进行引用（内存地址）传递，导致多个拷贝对象共用一个成员变量。

2)深拷贝
拷贝的类及成员对象的类实现Serializable接口。
在克隆方法内通过字节数组流和对象流将其序列化，再反序列化。
（也可以用JSON工具类将其序列化成JSON）

建造者模式
一个产品类（可以有多个产品实现类实现一个产品接口，但这些产品都必须能被同一个Build抽象类建造）。
一个Build抽象类定义建造方法模板，多个Build实现类各自重写建造方法。
一个Director类接收Build对象，不同Build对象执行不同的建造方法，并返回对应产品。
隔离了复杂对象的创建过程，符合开闭原则，要求产品差异不大。
工厂方法模式关注整体对象的创建方法，而建造者模式关注创建对象的过程。

适配器模式
将类的接口转换成期望的另一个接口表示，目的是兼容性，让原本接口不匹配的两个类可以协同工作。
三种经典模式是根据源类如何给到适配器类命名的。
1)类适配器模式
一个适配器类，继承源类，实现目标类接口，完成源->目标的适配。
由于继承源类，可以根据需求重写源类方法，更灵活。
但因为单继承，一次只能适配一个源类，所以目标类必须为接口，有局限性，且源类的方法在适配器类中会暴露出来。

2)对象适配器模式
一个适配器类，组合(关联)源类，实现目标类接口，完成源->目标的适配。
用组合代替继承，符合合成复用原则，可以适配不同的源到同一个目标。

3)接口适配器模式
一个接口类(源)，一个抽象类(适配器)实现接口类并为每个方法提供默认实现，抽象类的子类可以选择性地重写部分方法。

桥接模式
一个接口类和多个具体实现类，负责定义一些底层的操作。
一个抽象类和多个抽象类子类，抽象类关联(聚合)具体实现类对象并定义抽象方法，抽象类子类负责扩展抽象方法。
将实现与抽象分离，使他们可以独立改变。将继承关系转换成关联关系，降低耦合度。

装饰者模式
不改变原有对象，动态地将功能加到对象上，比继承更有弹性，符合开闭原则。
多个装饰者类实现一个装饰者抽象类，装饰者抽象类组合被装饰者并继承被装饰者类。





















JDK中RunTime类的单例模式就是饿汉式(静态常量)。
JDK中Calendar，Logger类的对象创建就是简单工厂模式。
Spring中getBean用到了原型模式。
JDK中的StringBuilder用到了建造者模式。
//StringBuilder指挥者，AbstractStringBuilder建造者实现，Appendable建造者接口。
SpringMVC中的HandlerAdapter用到了适配器模式。
//DispatcherServlet有一个List集合存放所有实现HandlerAdapter接口的适配器。
//DispatcherServlet获取到handler后遍历List集合，调用每个适配器的support方法进行判断。
//如果handler符合这个适配器(判断为真)，就返回该适配器，最后调用适配器的handle方法执行。
//符合单一职责原则，迪米特法则，开闭原则。
JDBC的DriverManager用到了桥接模式。
//Driver就是接口，下面有MySQL，Oracle的Driver具体实现(实现层)。
//DriverManager作为桥(抽象层)。Driver在初始化时会注册到DriverManager中。
//JDBC定义了标准接口(Connection,Statement,ResultSet)，具体实现由各个数据库提供。
//DriverManager关联这些接口实现，比如getConnection。(桥接模式的两个维度应该是数据库种类和操作数据的接口。)















synchronized 禁止重排序是通过内存屏障实现的, 简单来说, 内存屏障只保证指令不会越过该屏障, 而synchronized块内部的指令仍然有可能发生重排序


静态方法属于类，在编译阶段类被加载时，类的静态方法或者属性就会被分配内存，存储到类所在的内存中（堆内存的方法区中）；而类的非静态方法却是属于对象的，每个对象都有一份非静态方法的引用，并且若方法被重写，引用的就是子类重写的方法，且这是在运行时创建；
正因如此，即使子类重写了父类的静态方法，但是本质上它们还是两个独立的类，在内存中分别占用不同的内存，它们的静态方法也是在编译时就被加载，独立的占用着不同的内存。上面的代码中，一个父类的变量，指向子类的对象，调用一个被子类重写的静态方法时，由于这是一个父类的变量，并且静态方法属于类，所以在调用时，JVM会去父类所在的内存中寻找这个方法，所以最终的结果就是调用父类的方法，而不是子类重写的方法。

 