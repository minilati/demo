设计模式的目的
1)代码重用性(相同功能的代码，不用多次编写)
2)可读性(编程规范性,便于阅读和理解)
3)可扩展性(增加新功能时非常方便，称为可维护)
4)可靠性(增加新功能后，对原功能没有影响)
5)使程序呈现高内聚，低耦合的特性

设计模式七大原则
1)单一职责原则
一个类只负责一项职责。

2)接口隔离原则
一个类对另一个类的依赖应该建立在最小的接口上，细化接口，接口中的方法尽量少。

3)依赖倒转原则
中心思想是面向接口编程。
高层模块不应该依赖低层模块，二者都应该依赖其抽象。
抽象不应该依赖细节，细节应该依赖抽象。
传递依赖关系有三种方式：接口传递，构造方法传递，setter方法传递。
抽象的接口或抽象类比具体的实现类更稳定。

4)里氏替换原则
子类可以实现父类的抽象方法，但不能重写父类的非抽象方法。
子类中可以增加自己特有的方法。
继承让两个类的耦合度增强，可以通过聚合、组合、依赖来解决问题。

5)开闭原则
对扩展开放，对修改关闭。
用抽象构建框架，用实现扩展细节。
遵循其它原则，使用设计模式的目的就是遵循开闭原则。

6)迪米特法则
一个类对依赖的类知道的越少越好，被依赖的类应该将逻辑封装在内部，对外只提供public方法。
出现成员变量、方法参数、方法返回值中的类为直接朋友。类只与直接朋友通信。
出现在局部变量中的不是直接朋友，陌生类尽量不要以局部变量形式出现在类中。

7)合成复用原则
尽量使用合成/聚合的方式，而不是使用继承。

UML类图用于描述类的组成和类之间的各种静态关系。
1)依赖
①类中用到了对方
②是类的成员属性
③是方法的返回类型
④是方法接收的参数类型
⑤方法中使用到（虽然违反迪米特法则）

2)泛化
泛化就是继承关系，是依赖关系的特例。

3)实现
实现就是A类实现B接口，是依赖关系的特例

4)关联
关联就是类与类之间的联系，是依赖关系的特例。
具有导航性，即双向关系或单向关系。
单向：A类中有B类成员属性。
双向：A类中有B类成员属性，B类中有A类成员属性。

5)聚合
是整体和部分的关系，整体和部分可以分开，是关联关系的特例。
具有关联的导航性与多重性。
A类对象创建后，B类对象可以随时创建与销毁。

6)组合
是整体与部分的关系，整体与部分不可以分开。
A类对象一旦创建，B类对象也会被创建。A类对象一旦销毁，B类对象也会被销毁。


设计模式分为三种类型（共23种）
1)创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式。
2)结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
3)行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)。

单例设计模式八种方式
1)饿汉式(静态常量)
构造器私有化(防止new)
类的内部创建对象（private final static A a = new A()）
向外暴露一个静态公共方法来获取对象。
优点：类装载时完成实例化，避免了线程同步问题。
缺点：可能提前导致类装载从而创建对象，没有达到懒加载的效果。如果一直不用这个对象，则会造成内存浪费。

2)饿汉式（静态代码块）
将类实例化的过程放在了静态代码块中（private final static A a; static{a = new A();}）
也是在类加载时完成实例化，同上。

3)懒汉式(线程不安全)
向外暴露一个静态公共方法来获取对象。
在获取对象时，判断对象是否被创建，若对象为空则创建。
起到了懒加载的效果，但是只能在单线程下使用。
如果在多线程下，多个线程同时判断对象为空，则会创建多个对象，因此不是单例模式。

4)懒汉式(线程安全，同步方法)
在获取对象的方法上加上synchronized锁。
虽然解决线程安全问题，但是效率低下，实际只需进行一次实例化，后续请求可直接返回对象没必要同步。

6)双重检查
volatile修饰对象，在获取对象方法内部两个if判断间加synchronized锁。
private static volatile A a;
if(a==null){   synchronized(A.class){   if(a==null) {   a=new A()...
用volatile修饰对象防止指令重排序。new一个对象并不是原子指令，分为3步：
1.分配对象内存
2.调用构造器执行初始化
3.将对象引用赋值给变量
第1步先执行，第2、3步可能发生重排序。
当线程A执行完1,3步却还未初始化对象时，线程B会因为判断该对象非空而去访问对象造成异常。
延迟加载，效率较高，推荐使用！

7)静态内部类
在类中写一个静态内部类，其中有一个主类对象的静态属性。
获取对象时直接返回内部类的静态属性。
class A{
private static A a;
private static class AIns{ private static final A a=new A();}
private static A getA(){return AIns.a;}
}
静态内部类只有在第一次被调用时才会加载，并且类的静态属性只会在第一次加载类时初始化。
线程安全，延迟加载，效率高，推荐使用。

8)枚举
在类中定义一个枚举类，枚举类中有一个枚举对象和主类对象，并在构造器中初始化主类，对外暴露公共方法返回主类对象。
class A{
enum AIns{		//枚举类只能自己实例化
INSTANCE;		//枚举类对象
private final A a;		//主类对象
AIns(){a=new A();}		//构造器中初始化主类
public A getA(){return a;}	//对外暴露获取对象方法
线程安全，延迟加载，防止反序列化，推荐使用！

工厂模式
解耦，使对象的创建和使用分开，易于扩展，符合开闭原则，封装性，对外只暴露基类，不用自己准备参数new对象。
1)简单工厂模式
定义一个产品接口，多个产品实现类，一个工厂类。
在工厂类中定义一个公共静态方法，根据传入的参数创建对应产品对象并返回。
（工厂类中用静态方法可以直接用工厂类生产对象而不用创建工厂对象，不过子工厂类继承工厂类后无法重写静态的生产方法）

2)工厂方法模式
定义一个产品接口，多个产品实现类，一个工厂抽象类，多个工厂实现类。
将原本工厂创建产品对象的任务分发给多个具体工厂实现类。
在工厂实现类中重写生产方法，创建对应产品对象并返回。
（这里因为要重写生产方法，所以工厂类的生产方法是非静态的，也就需要创建工厂对象调用方法来生产对象）

3)抽象工厂模式
定义多个产品接口，多个产品实现类，一个工厂抽象类，多个工厂实现类。
与工厂方法模式不同的是，不需要每多一种产品就创建一个工厂实现类。
而是在工厂抽象类中增加创建产品对象的接口，再由工厂实现类重写生产方法，创建对应产品对象并返回。
（如果某些产品只有部分工厂实现类能生产，那么该产品生产方法不应写进接口，而是直接写进实现类？）

原型模式
1)浅拷贝
拷贝的类实现Cloneable接口，重写clone方法。
对于基本数据类型的成员变量，浅拷贝进行值传递。（String也是值传递）
对于引用数据类型的成员变量，浅拷贝进行引用（内存地址）传递，导致多个拷贝对象共用一个成员变量。

2)深拷贝
拷贝的类及成员对象的类实现Serializable接口。
在克隆方法内通过字节数组流和对象流将其序列化，再反序列化。
（也可以用JSON工具类将其序列化成JSON）

建造者模式
一个产品类（可以有多个产品实现类实现一个产品接口，但这些产品都必须能被同一个Build抽象类建造）。
一个Build抽象类定义建造方法模板，多个Build实现类各自重写建造方法。
一个Director类接收Build对象，不同Build对象执行不同的建造方法，并返回对应产品。
隔离了复杂对象的创建过程，符合开闭原则，要求产品差异不大。
工厂方法模式关注整体对象的创建方法，而建造者模式关注创建对象的过程。

适配器模式
将类的接口转换成期望的另一个接口表示，目的是兼容性，让原本接口不匹配的两个类可以协同工作。
三种经典模式是根据源类如何给到适配器类命名的。
1)类适配器模式
一个适配器类，继承源类，实现目标类接口，完成源->目标的适配。
由于继承源类，可以根据需求重写源类方法，更灵活。
但因为单继承，一次只能适配一个源类，所以目标类必须为接口，有局限性，且源类的方法在适配器类中会暴露出来。

2)对象适配器模式
一个适配器类，组合(关联)源类，实现目标类接口，完成源->目标的适配。
用组合代替继承，符合合成复用原则，可以适配不同的源到同一个目标。

3)接口适配器模式
一个接口类(源)，一个抽象类(适配器)实现接口类并为每个方法提供默认实现，抽象类的子类可以选择性地重写部分方法。

桥接模式
一个接口类和多个具体实现类，负责定义一些底层的操作。
一个抽象类和多个抽象类子类，抽象类关联(聚合)具体实现类对象并定义抽象方法，抽象类子类负责扩展抽象方法。
将实现与抽象分离，使他们可以独立改变。将继承关系转换成关联关系，降低耦合度。

装饰者模式
一个主类(被装饰者)抽象类，多个主体实现类。
一个装饰者抽象类继承主类，并将主类对象作为他的实例变量。(继承并组合主类)
多个装饰者实现类继承装饰者抽象类，作为装饰者对象，在初始化装饰者对象时传入主类对象，多个装饰者则依次递归。(装饰者和主类实现的父类都是主类)
不改变原有对象，动态地将功能加到对象上，比继承更有弹性，符合开闭原则。

组合模式
非叶子节点和叶子节点实现统一接口，非叶子节点内组合该接口，并含有List作为内部属性存放非叶子和叶子节点对象。
将对象组合成树形结构以表示部分-整体的层次结构。高层模块调用简单，节点自由增加。
组合模式使得用户对单个对象和组合对象的使用具有一致性(都实现了统一接口)。
需要较高抽象性，非叶子和叶子节点差异不能过大，违反依赖倒置原则。

外观模式
一个外观类，为用户提供统一的调用接口。
多个子系统类，聚合到外观类中，将多个子系统操作方法放入一个外观类调用接口中。
外观模式定义了一个高层接口，隐藏内部子系统细节，降低访问系统时的复杂度。

享元模式
一个享元角色接口，一个享元角色具体实现类，定义出对象内部状态和外部状态(内部状态可共享，外部状态不可共享)。
一个享元工厂类，构建一个池容器(HashMap)，提供从池中获取享元对象的方法。
减少对象的创建，减少内存占用并提高性能。提高了系统的复杂度，需要分离出外部状态和内部状态。

代理模式
1)静态代理
需要目标类和代理类实现相同接口或继承共同父类。
代理类组合目标类，通过调用目标对象的方法来实现代理。
代理类需要与目标类实现一样的接口，可能会有很多代理类，新增方法两边都需要维护。

2)JDK代理(接口代理)
目标对象必须实现接口,利用JDK的API动态地在内存中构建代理对象。
代理工厂类组合目标类，通过代理工厂来获取代理对象，java.lang.reflect.Proxy包中的newProxyInstance()可以获取代理对象。
只需要传入目标类加载器，目标类实现接口，以及代理方法实现。
方法实现中用method.invoke(obj,args)实现目标方法调用。(通过反射执行方法)

3)CGLib
目标对象不需要实现接口,通过在内存中构建增强子类重写目标类方法来实现代理。(代理类为增强子类)
代理工厂类实现MethodInterceptor接口(导入cglib包)并重写intercept方法(方法拦截器)。
代理工厂类提供获取增强子类对象的方法(创建Enhancer增强对象设置父类与回调函数并返回)。
目标类不能为final，如果目标类中的方法为final/static，则不会被拦截。
(FastClass机制：给每个方法编号，通过编号直接执行原类的方法，不用反射效率更高。)

模板方法模式
一个抽象类公开定义了模板方法(可实现可抽象)，不想被重写的模板方法可加final，多个子类可以按需重写方法，但调用将以抽象类中定义的方式进行。
在抽象类中可以定义一个钩子方法，默认不做任何事，子类可以根据情况重写钩子方法，在抽象类的代码中可以根据钩子方法来选择不同的实现。
统一了算法，也提供很大灵活性，一系列步骤基本相同时可用。

命令模式
一个命令接口，声明执行与撤销方法。多个接收者类，里面实现真正的操作方法，并聚合到具体命令实现类。
多个具体命令实现类实现该命令接口，重写执行与撤销方法。(重写方法中调用到真正执行操作的接收者方法)
一个命令者类，命令接口聚合到命令者类中，一般维护一个命令集合，每个命令都是一个对象，可记录上一步命令以准备撤销。
请求发送者调用命令者，命令者再调用请求接收者，将请求发送者与请求接收者解耦。但命令过多可能导致类爆炸。

访问者模式
一个被访问者接口，声明一个方法接收访问者。
多个被访问者实现类及一个数据结构类实现被访问者接口，并重写接收方法，将自身(被访问者)引用传入访问者的访问方法。
数据结构类维护一个被访问者集合，可以接收一个访问者并批量执行各个被访问者的接收方法。
一个访问者接口，声明多个访问方法，接收不同对象的引用。一个访问者实现类实现访问者接口，重写访问方法，
主要将数据结构与数据操作分离，解决稳定的数据结构和易变的操作耦合问题。符合单一职责原则。
具体元素对访问者公布细节，违反了迪米特原则。具体元素变更比较困难。依赖了具体类，没有依赖抽象，违反了依赖倒置原则。

迭代器模式
一个容器接口，声明一个获取迭代器的方法。多个容器实现类聚合不同类型的数据集合，重写方法获取对应的那个迭代器。
一个迭代器接口(Iterator)，声明hasNext()和next()方法，多个迭代器实现类，一种数据结构对应一个迭代器，重写对应的方法。
提供统一方法获取迭代器来对不同对象遍历，隐藏内部结构，将管理对象与遍历对象的责任分开，符合单一职责原则。
一个新的对象集合需要一个新的迭代器类，可能会增加系统复杂性。

观察者模式
一个被观察者接口，声明注册观察者，移除观察者，通知观察者方法。
一个被观察者实现类，重写各方法，并维护一个List存放观察者，可以遍历List通知所有观察者执行更新方法(最好采用异步，顺序执行可能会因为某一观察者错误导致系统卡死)。
一个观察者接口，声明更新方法。多个观察者实现类，重写更新方法。
定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。观察者和被观察者是抽象耦合的并且有一套触发机制。

中介者模式
多个同事类(可抽象出接口)，将中介者对象作为成员变量，在构造器中初始化成员变量并将自己注册到中介类里，完成发送消息方法(调用中介对象的接收消息方法)。
一个中介类(可抽象出接口)，维护同事对象集合，完成注册同事方法。完成接收消息方法(核心)，根据接收的消息执行对应方法。
多个类相互通信，将网状结构分离为星型结构(中间点为中介类)，一对多转化成一对一，符合迪米特原则。但中介者类会变得复杂难以维护。

备忘录模式
一个源类(Originator)，需要实现保存对象状态与获取对象状态方法。一个备忘录类(Memento)，负责保存源类对象状态。
一个守护者类(CareTaker)，负责保存多个备忘录对象，用集合管理。(如果想保存一个对象不同时期的多个状态，可用Map<String,List<Memento>>)实现。
提供了一种可以恢复状态的机制，实现了信息的封装。如果源类需要保存的信息很多，则会消耗较大资源。

解释器模式
一个表达式抽象类(Expression)，声明interpret方法。定义终结表达式实现类与其他表达式实现类，重写interpret方法。
先解析语句，构建表达式语法树，最后执行表达式的interpret方法。
对于一些固定文法构建一个解释句子的解释器，通过构建语法树，定义终结符与非终结符来解释。

状态模式
一个主类组合一个状态接口，将状态作为实例成员变量。多个状态实现类实现状态接口，重写各自状态下的方法。
当对象的行为依赖于状态时，可以将状态抽象成接口，再由各个状态实现类去实现并重写各自方法，这样状态改变时，对象的行为也会改变。
减少了if-else分支，增强可读性，维护性。

策略模式
一个主类，聚合一个策略接口，并实现对应策略的执行方法。
一个策略接口，声明策略执行方法。多个策略实现类，实现不同的策略执行方法。
将多个算法封装成不同的策略类，并实现同一策略接口，可以任意的替换，符合开闭原则。一个策略就需要一个类，可能导致类爆炸。

责任链模式
一个处理者接口，声明处理方法并聚合自己(表示下一个处理者)。
多个处理者实现类实现统一接口，重写自己的处理方法并定义下一个处理者(如果自己处理不了将交给下一个处理者处理)。
请求发送者与接收者解耦，只需要将请求发送到职责链上，无须关心请求的处理细节和传递。
多级请求时可用，但调试不方便。

设计模式在源码中的应用
JDK中RunTime类的单例模式就是饿汉式(静态常量)。

JDK中Calendar，Logger类的对象创建就是简单工厂模式。

Spring中getBean用到了原型模式。

JDK中的StringBuilder用到了建造者模式。
//StringBuilder指挥者，AbstractStringBuilder建造者实现，Appendable建造者接口。

SpringMVC中的HandlerAdapter用到了适配器模式。
//DispatcherServlet有一个List集合存放所有实现HandlerAdapter接口的适配器。
//DispatcherServlet获取到handler后遍历List集合，调用每个适配器的support方法进行判断。
//如果handler符合这个适配器(判断为真)，就返回该适配器，最后调用适配器的handle方法执行。
//符合单一职责原则，迪米特法则，开闭原则。

JDBC的DriverManager用到了桥接模式。
//Driver就是接口，下面有MySQL，Oracle的Driver具体实现(实现层)。
//DriverManager作为桥(抽象层)。Driver在初始化时会注册到DriverManager中。
//JDBC定义了标准接口(Connection,Statement,ResultSet)，具体实现由各个数据库提供。
//DriverManager关联这些接口实现，比如getConnection。(桥接模式的两个维度应该是数据库种类和操作数据的接口。)

JDK中的IO用到了装饰者模式。
//被装饰者抽象类：InputStream
//被装饰者继承类：FileInputStream，ObjectInputStream，ByteArrayInputStream...
//装饰者抽象类：FilterInputStream
//装饰者继承类：DataInputStream，BufferedInputStream

JDK中的HashMap用到了组合模式。
//Map是抽象接口，AbstractMap抽象类实现Map接口，HashMap继承AbstractMap并实现Map。
//HashMap就是非叶子节点，有put，putAll方法。
//Node是HashMap的静态内部类，就是叶子节点，没有put，putAll方法。

Mybatis中的Configuration用到了外观模式。
//Configuration为外观类，创建MetaObject时他封装了内部实现细节，用户直接调用forObject就可以得到MetaObject对象。
//DefaultObjectFactory，DefaultObjectWrapperFactory，DefaultReflectorFactory为子系统类，组合到Configuration中。

JDK中Integer.valueOf()用到了享元模式。
//Integer有一个静态内部类IntegerCache，有一个cache数组存放-128~127的整数。
//如果Integer.valueOf(n)时n的范围在这之间，则直接返回cache数组中的对应值。
//String常量池，数据库连接池，缓冲池等都用到了享元模式。

SpringIOC容器初始化时用到了模板方法模式。
//ConfigurableApplicationContext接口声明模板方法refresh()。
//抽象类AbstractApplicationContext实现了接口，主要实现了模板方法refresh()。
//声明了钩子方法postProcessBeanFactory()，onRefresh()，抽象方法getBeanFactory()，refreshBeanFactory()。
//AbstractRefreshableApplicationContext，GenericApplicationContext子类实现抽象方法getBeanFactory()，refreshBeanFactory()。

Spring的JdbcTemplate用到了命令模式。
//JdbcTemplate为请求发送者，execute(StatementCallback<T> action)方法中，调用action.doInStatement()方法。
//StatementCallback为命令接口(Command)，不同的类实现该接口，重写不同的doInStatement()方法。
//匿名内部类QueryStatementCallback实现命令接口，重写了doInStatement()方法，该类也充当命令接收者。
//实现命令接口的还有ExecuteStatementCallback，UpdateStatementCallback，BatchUpdateStatementCallback。

JDK的List用到了迭代器模式。
//Iterator是迭代器接口，系统提供。
//List是容器接口，声明iterator()方法返回一个迭代器对象，LinkedList，Arraylist实现该接口。
//ArrayList重写了iterator()，其中内部类Itr实现Iterator接口，为迭代器实现类，并重写了hasNext和next方法，其数据结构由数组实现。

JDK的Observable用到了观察者模式。
//Observable为被观察者(无接口)，维护一个观察者Vector集合，有添加、移除、通知观察者的方法。
//Observer接口为观察者接口，声明了更新方法。

SpringMVC用到了中介者模式，controller层就是中介者。

Spring的SpelExpressionParser用到了解释器表达式。
//Expression为表达式接口，下面有不同的实现类SpelExpression，CompositeStringExpression。
//根据不同的条件获取不同的Expression对象(源码位于TemplateAwareExpressionParser)，最后调用该对象的getValue方法得到值。

JDK的Arrays.sort的Comparator用到了策略模式。
//Comparator是策略接口，可以在Arrays.sort(T[] a, Comparator<? super T> c)中传入实现策略接口的对象。
//可以自己new一个比较器对象实现compare()方法，也可以用lambda表达式。

SpringMVC的HandlerExecutionChain用到了责任链模式。
//HandlerExecutionChain负责请求拦截器的执行与请求处理，本身不执行拦截器的逻辑，只是将请求分配给链上注册的拦截器执行。
//HandlerExecutionChain维护了HandlerInterceptor(拦截器)集合。
